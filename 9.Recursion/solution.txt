9001. Pow(x, n) ||Medium 
class Solution {
    public double myPow(double x, int n) {
        double ans = 1.0;
        long nn = n;//change n to nn to avoid integer overflow for int absolute value
        if (nn < 0) nn = nn * -1; //conver negative value to positive
        while (nn > 0) {
            //odd nn
            if (nn % 2 == 1) {
                ans = ans * x;
                nn = nn - 1;
            } else {
                x = x * x;
                nn = nn / 2;
            }
        }
        if (n < 0)
            return (double) 1.0 / (double) ans;
        return ans;
    }
}

9002. class Solution {
    
    static final long MOD = 1_000_000_007;

    // Fast exponentiation function
    public long power(long base, long exponent) {
        long result = 1;
        base = base % MOD;

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            //Optimize exponentiation
            exponent /= 2;
        }

        return result;
    }

    public int countGoodNumbers(long n) {
        long evenCount = (n + 1) / 2; // ceil(n / 2)
        long oddCount = n / 2;        // floor(n / 2)

        long evenChoices = power(5, evenCount);
        long oddChoices = power(4, oddCount);

        return (int)((evenChoices * oddChoices) % MOD);
    }

}

9003. 

 class Solution {
    public List<String> generateBinaryStrings(int n) {
        int zeroended=1;
        int oneendedd=1;
        int sum= zeroended+oneendedd;
        int i=2;
        while(n<i){  //Compare length with number of steps taken to build string as i
            if(n=1) return sum;
            oneendedd=zeroended % (100000007); //MODs to avoid large numbers
            zeroended=sum % (100000007);
            sum=(oneendedd+zeroended) % (100000007);
            i++;
        }
        return sum;
    }
 }

 9004.
   Generate Parathesis
   class Solution {
    public List<String> generateParenthesis(int n) {

        List<String> result = new ArrayList<>();
        backtrack(n, n, result, "");
        return result;
    }

    void backtrack(int openN, int closeN, List<String> result, String current) {
        //Base case
        if (openN == 0 && closeN == 0) {
            result.add(current);
            return;
        }
        // Add '(' if any are left
        if (openN>0) {
            backtrack(openN - 1, closeN, result, current + "(" );
        }
        //Add ')' only if it won't break the balance
        if (closeN>openN) {
            backtrack( openN, closeN - 1, result, current + ")" );
        }
    }
}


9006. 
         private recSorted(int[] arr, int index) {
        if (index == arr.length - 1) {
            return true;
        }
        return arr[index] < arr[index + 1] && recSorted(arr, index + 1);
    }   
         
9005.

    public class BinarySRec {
    public static void main(String[] args) {
        int target = 4;
        int[] arr = {2, 4, 5, 6, 7};
        int result = binaryRec(arr, target, 0, arr.length - 1);
        System.out.println(result);
    }

    private static int binaryRec(int[] arr, int target, int s, int e) {
        if (s > e) {
            return -1;
        }
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        if (target < arr[m]) {
            return binaryRec(arr, target, s, m - 1);
        }
        return binaryRec(arr, target, m + 1, e);
    }


 9007. 
       public class ReduceTo {
    public static void main(String[] args) {
        int n=14;
        System.out.println(reduce(n));
    }
  //Create a helper method when you have to pass the argument as changing value in the recursive call
    private static int reduce(int n) {
        return helper(n,0);
    }

    private static int helper(int n, int c) {
        if(n==0){
            return c;
        }
        if(n%2==0){
           return helper(n/2,c+1);
        }
       return helper(n-1,c+1);
    }    

9005.
    public class BinarySRec {
    public static void main(String[] args) {
        int target = 4;
        int[] arr = {2, 4, 5, 6, 7};
        int result = binaryRec(arr, target, 0, arr.length - 1);
        System.out.println(result);
    }

    private static int binaryRec(int[] arr, int target, int s, int e) {
        if (s > e) {
            return -1;
        }
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        if (target < arr[m]) {
            return binaryRec(arr, target, s, m - 1);
        }
        return binaryRec(arr, target, m + 1, e);
    }
9006. 
         private recSorted(int[] arr, int index) {
        if (index == arr.length - 1) {
            return true;
        }
        return arr[index] < arr[index + 1] && recSorted(arr, index + 1);
    }

9007.    
      private static Boolean search(int[] arr,int target, int index) {
        if (index == arr.length - 1) {
            return false;
        }
        return arr[index]==target ||  search(arr,target,index+1);
    }

9008.
       int sortedCheck(int[] arr, int s, int e, int target) {
        //Base case as couldn't find target
        if (s > e) {
            return -1;
        }
        //if mid element is the target element
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        //if mid is greater than start(left half is sorted) -->element range is fixed here
        if (arr[m] >= arr[s]) {
            if (target >= arr[s] && target <= arr[m]) {
                return sortedCheck(arr, s, m - 1, target);
            } else {
                return sortedCheck(arr, m + 1, arr.length - 1, target);
            }
        }
        //if mid is smaller than end (right half is sorted) -->element range is fixed here
        else {
            if (target >= arr[m] && target <= arr[e]) {
                return sortedCheck(arr, m + 1, e, target);
            }
            return sortedCheck(arr, s, m - 1, target);
        }
    }

9009. 

    public class BubbleSortRec {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 2};
        sort(arr, arr.length - 1, 0);
        System.out.println(Arrays.toString(arr));
    }

    private static void sort(int[] arr, int length, int count) {
        //Base case--> when length became 0 just return
        if (length == 0) {
            return;
        }
        /*if count is smaller than length keep on comparing and swap if required
         to push the largest number to end*/
        if (count < length) {
            //check if next element is smaller
            if (arr[count] > arr[count + 1]) {
                //if yes swap
                int temp = arr[count];
                arr[count] = arr[count + 1];
                arr[count + 1] = temp;
            }
            //after swap check same element to the other next elements
            sort(arr, length, count + 1);
        }
        //after one iteration is done reduce the comparison size by 1
        sort(arr, length - 1, 0);
    }
}

9010. 

     public class SelectionSort {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 2};

        sort(arr, arr.length , 0,0);
        System.out.println(Arrays.toString(arr));
    }

     static void sort(int[] arr, int r, int c,int maxIdx) {
        //Base case
        if(r==0){
            return;
        }
        //Make element comparison from c(Current left index) to r(end index)
        if(c<r){
            if(arr[c]>arr[maxIdx]){
                sort(arr,r,c+1,c);
            }else{
                sort(arr,r,c+1,maxIdx);
            }
        }else{
            int temp=arr[maxIdx];
            arr[maxIdx]=arr[r-1];
            arr[r-1]=temp;
        }
        sort(arr,r-1,0,0);

    }
}