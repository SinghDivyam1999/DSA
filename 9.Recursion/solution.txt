9001. Pow(x, n) ||Medium 
class Solution {
    public double myPow(double x, int n) {
        double ans = 1.0;
        long nn = n;//change n to nn to avoid integer overflow for int absolute value
        if (nn < 0) nn = nn * -1; //conver negative value to positive
        while (nn > 0) {
            //odd nn
            if (nn % 2 == 1) {
                ans = ans * x;
                nn = nn - 1;
            } else {
                x = x * x;
                nn = nn / 2;
            }
        }
        if (n < 0)
            return (double) 1.0 / (double) ans;
        return ans;
    }
}

9002. class Solution {
    
    static final long MOD = 1_000_000_007;

    // Fast exponentiation function
    public long power(long base, long exponent) {
        long result = 1;
        base = base % MOD;

        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % MOD;
            }
            base = (base * base) % MOD;
            //Optimize exponentiation
            exponent /= 2;
        }

        return result;
    }

    public int countGoodNumbers(long n) {
        long evenCount = (n + 1) / 2; // ceil(n / 2)
        long oddCount = n / 2;        // floor(n / 2)

        long evenChoices = power(5, evenCount);
        long oddChoices = power(4, oddCount);

        return (int)((evenChoices * oddChoices) % MOD);
    }

}

9003. 

 class Solution {
    public List<String> generateBinaryStrings(int n) {
        int zeroended=1;
        int oneendedd=1;
        int sum= zeroended+oneendedd;
        int i=2;
        while(n<i){  //Compare length with number of steps taken to build string as i
            if(n=1) return sum;
            oneendedd=zeroended % (100000007); //MODs to avoid large numbers
            zeroended=sum % (100000007);
            sum=(oneendedd+zeroended) % (100000007);
            i++;
        }
        return sum;
    }
 }

 9004.
   Generate Parathesis
   class Solution {
    public List<String> generateParenthesis(int n) {

        List<String> result = new ArrayList<>();
        backtrack(n, n, result, "");
        return result;
    }

    void backtrack(int openN, int closeN, List<String> result, String current) {
        //Base case
        if (openN == 0 && closeN == 0) {
            result.add(current);
            return;
        }
        // Add '(' if any are left
        if (openN>0) {
            backtrack(openN - 1, closeN, result, current + "(" );
        }
        //Add ')' only if it won't break the balance
        if (closeN>openN) {
            backtrack( openN, closeN - 1, result, current + ")" );
        }
    }
}


9006. 
         private recSorted(int[] arr, int index) {
        if (index == arr.length - 1) {
            return true;
        }
        return arr[index] < arr[index + 1] && recSorted(arr, index + 1);
    }   
         
9005.

    public class BinarySRec {
    public static void main(String[] args) {
        int target = 4;
        int[] arr = {2, 4, 5, 6, 7};
        int result = binaryRec(arr, target, 0, arr.length - 1);
        System.out.println(result);
    }

    private static int binaryRec(int[] arr, int target, int s, int e) {
        if (s > e) {
            return -1;
        }
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        if (target < arr[m]) {
            return binaryRec(arr, target, s, m - 1);
        }
        return binaryRec(arr, target, m + 1, e);
    }


 9007. 
       public class ReduceTo {
    public static void main(String[] args) {
        int n=14;
        System.out.println(reduce(n));
    }
  //Create a helper method when you have to pass the argument as changing value in the recursive call
    private static int reduce(int n) {
        return helper(n,0);
    }

    private static int helper(int n, int c) {
        if(n==0){
            return c;
        }
        if(n%2==0){
           return helper(n/2,c+1);
        }
       return helper(n-1,c+1);
    }    

9005.
    public class BinarySRec {
    public static void main(String[] args) {
        int target = 4;
        int[] arr = {2, 4, 5, 6, 7};
        int result = binaryRec(arr, target, 0, arr.length - 1);
        System.out.println(result);
    }

    private static int binaryRec(int[] arr, int target, int s, int e) {
        if (s > e) {
            return -1;
        }
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        if (target < arr[m]) {
            return binaryRec(arr, target, s, m - 1);
        }
        return binaryRec(arr, target, m + 1, e);
    }
9006. 
         private recSorted(int[] arr, int index) {
        if (index == arr.length - 1) {
            return true;
        }
        return arr[index] < arr[index + 1] && recSorted(arr, index + 1);
    }

9007.    
      private static Boolean search(int[] arr,int target, int index) {
        if (index == arr.length - 1) {
            return false;
        }
        return arr[index]==target ||  search(arr,target,index+1);
    }

9008.
       int sortedCheck(int[] arr, int s, int e, int target) {
        //Base case as couldn't find target
        if (s > e) {
            return -1;
        }
        //if mid element is the target element
        int m = s + (e - s) / 2;
        if (arr[m] == target) {
            return m;
        }
        //if mid is greater than start(left half is sorted) -->element range is fixed here
        if (arr[m] >= arr[s]) {
            if (target >= arr[s] && target <= arr[m]) {
                return sortedCheck(arr, s, m - 1, target);
            } else {
                return sortedCheck(arr, m + 1, arr.length - 1, target);
            }
        }
        //if mid is smaller than end (right half is sorted) -->element range is fixed here
        else {
            if (target >= arr[m] && target <= arr[e]) {
                return sortedCheck(arr, m + 1, e, target);
            }
            return sortedCheck(arr, s, m - 1, target);
        }
    }

9009. 

    public class BubbleSortRec {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 2};
        sort(arr, arr.length - 1, 0);
        System.out.println(Arrays.toString(arr));
    }

    private static void sort(int[] arr, int length, int count) {
        //Base case--> when length became 0 just return
        if (length == 0) {
            return;
        }
        /*if count is smaller than length keep on comparing and swap if required
         to push the largest number to end*/
        if (count < length) {
            //check if next element is smaller
            if (arr[count] > arr[count + 1]) {
                //if yes swap
                int temp = arr[count];
                arr[count] = arr[count + 1];
                arr[count + 1] = temp;
            }
            //after swap check same element to the other next elements
            sort(arr, length, count + 1);
        }
        //after one iteration is done reduce the comparison size by 1
        sort(arr, length - 1, 0);
    }
}

9010. 

     public class SelectionSort {
    public static void main(String[] args) {
        int[] arr = {1, 3, 4, 2};

        sort(arr, arr.length , 0,0);
        System.out.println(Arrays.toString(arr));
    }

     static void sort(int[] arr, int r, int c,int maxIdx) {
        //Base case
        if(r==0){
            return;
        }
        //Make element comparison from c(Current left index) to r(end index)
        if(c<r){
            if(arr[c]>arr[maxIdx]){
                sort(arr,r,c+1,c);
            }else{
                sort(arr,r,c+1,maxIdx);
            }
        }else{
            int temp=arr[maxIdx];
            arr[maxIdx]=arr[r-1];
            arr[r-1]=temp;
        }
        sort(arr,r-1,0,0);

    }
}

9011.
   --With new array 
       int[] sort(int[] arr) {
        //Base case
        if (arr.length == 1) {
            return arr;
        }
        int mid = arr.length / 2;
        //sort first part of the array
        int[] first = sort(Arrays.copyOfRange(arr, 0, mid));
        //sort second part of the array
        int[] last = sort(Arrays.copyOfRange(arr, mid, arr.length));
        //merge sorted parts after sorting them while merging
        return merge(first, last);

    }

     int[] merge(int[] first, int[] last) {
        int[] mix = new int[first.length + last.length];
        int i = 0, j = 0, k = 0;
        while (i < first.length && j < last.length) {
            //first[i]<last[j]
            if (first[i] < last[j]) {
                mix[k] = first[i];
                i++;
            } else {
                mix[k] = last[j];
                j++;
            }
            k++;
        }
        while(i<first.length){
            mix[k]=first[i];
            k++;
            i++;
        }
        while(j<last.length){
            mix[k]=last[j];
            k++;
            j++;
        }
        return mix;
    }

--In place
     **Insted of passing copy of array range pass directly indexes
        void sortInPlace(int[] arr,int s,int e) {
        //Base case(Means when just one element is left)
        if (e-s == 1) {
            return;
        }
        int mid = (s+e)/2;
        //sort first part of the array
        sortInPlace(arr, s, mid);
        //sort second part of the array
         sortInPlace(arr, mid, e);
        //merge sorted parts after sorting them while merging
         mergeInPlace(arr,s,mid,e);

    }

      static void mergeInPlace(int[] arr,int s,int mid,int e) {
        //Create a result array that will hold sorted resulted array
        int[] mix = new int[e-s];
        int i=s;
        int j=mid;
        int k=0; //counter var for index of result array
        while (i < mid && j < e) {
            //arr[i]<arr[j]
            if (arr[i] < arr[j]) {
                mix[k] = arr[i];
                i++;
            } else {
                mix[k] = arr[j];
                j++;
            }
            k++;
        }
        //If any sub part of the array length is less and some elements are still left for comparision
        while(i<mid){
            mix[k]=arr[i];
              k++;
            i++;
        }
        while(j<e){
            mix[k]=arr[j];
            k++;
            j++;
        }
        //Populate the result array in main array
        for(int l=0;l<mix.length;l++){
            arr[s+l]=mix[l];
        }
    }

    9012.


    public class QuickSort {
    public static void main(String[] args) {
        int[] num = {5, 4, 3, 2, 1};
        sort(num, 0, num.length - 1);
        System.out.println(Arrays.toString(num));
    }

    //Here low is left most index, hi is right most index
    private static void sort(int[] num, int low, int hi) {
        //Base case: left crosses right index
        if (low >= hi) {
            return;
        }
        int s = low; //current pointer of low set to s
        int e = hi;// current pointer hi set as e
        int m = s + (e - s) / 2;
        int pivot = num[m]; //chosen mid as pivot

        while (s <= e) {
            //No violation cases result in moving indexes
            while (num[s] < pivot) {
                s++;
            }
            while (num[e] > pivot) {
                e--;
            }
            //if violated swap the violating case
            if (s <= e) {
                int temp = num[s];
                num[s] = num[e];
                num[e] = temp;
                s++;
                e--;
            }
        }
        //recursive call we will have two sub arrays as
                //Recursive call is as per while (s <= e) condition which results in sub array as "low to e" && "s to h".
        sort(num, low, e);
        sort(num, s, hi);

    }
    }

    9013.


    public class MazeDigonalRec {
        public static void main(String[] args) {
            mazeDiagonal("", 3, 3);
        }

        static void mazeDiagonal(String p, int r, int c) {
            if (c == 1 && r == 1) {
                System.out.println(p);
            } else {
                //Go diagonal if you are not at last R or C
                if (r > 1 && c > 1) {
                    mazeDiagonal(p + "D", r - 1, c-1);
                }
                //Only go down when you have row left
                if (r > 1) {
                    mazeDiagonal(p + "V", r - 1, c);
                }
                //Only go down when you have column left --> left
                if (c > 1) {
                    mazeDiagonal(p + "H", r, c - 1);
                }

            }
        }
    }


    1914.

    package Recursion;

    public class MazeWithObstacle {
        public static void main(String[] args) {
            //false one is obstacle
            boolean[][] board = {
                    {true, true, true},
                    {true, false, true},
                    {true, true, true}
            };
            //p is processed result
            mazeObst("", board, 0, 0);
        }

        static void mazeObst(String p, boolean[][] board, int r, int c) {
            //if row is exhausted or column is exhausted
            if (r == board.length - 1 && c == board[0].length - 1) {
                System.out.println(p);
                return;
            }
            //if you are at obstacle return (No recursion calls of that branch
            if (!board[r][c]) {
                return;
            }
            //can go down if row is not exhausted
            if (r < board.length - 1) {
                mazeObst(p + "D", board, r + 1, c);
            }
            //can go right if column is not exhausted
            if (c < board[0].length - 1) {
                mazeObst(p + "R", board, r, c + 1);
            }

        }
    }

